---
image:
  # -- Traefik image host registry  (https://hub.docker.com/_/traefik)
  registry: docker.io
  # -- Traefik image repository
  repository: traefik
  # -- Explicitly specifying the newer version 3.0
  tag: "v3.0.0-beta3"
  # -- Traefik image pull policy
  pullPolicy: IfNotPresent

# -- Add additional label to all resources
commonLabels: {}
#
# Configure the deployment
#
deployment:
  # -- Enable deployment
  enabled: true
  # -- Deployment or DaemonSet
  kind: Deployment
  #####################################################################################################################
  # 'replicas:null' NEEDS To Be Specified Here For Horizontal Pod Scaling Configured Further Down When HPA Is Enabled #
  #####################################################################################################################
  # -- Number of pods of the deployment (only applies when kind == Deployment)
  replicas: 1
  # -- Number of old history to retain to allow rollback (If not set, default Kubernetes value is set to 10)
  # revisionHistoryLimit: 1
  # -- Amount of time (in seconds) before Kubernetes will send the SIGKILL signal if Traefik does not shut down
  terminationGracePeriodSeconds: 60
  # -- The minimum number of seconds Traefik needs to be up and running before the DaemonSet/Deployment controller considers it available
  minReadySeconds: 0
  ## Override the liveness/readiness port. This is useful to integrate traefik
  ## with an external Load Balancer that performs healthchecks.
  ## Default: ports.traefik.port
  # healthchecksPort: 9000
  ## Override the liveness/readiness scheme. Useful for getting ping to
  ## respond on websecure entryPoint.
  # healthchecksScheme: HTTPS
  # -- Additional deployment annotations (e.g. for jaeger-operator sidecar injection)
  annotations: {}
  # -- Additional deployment labels (e.g. for filtering deployment by custom labels)
  labels: {}
  # -- Additional pod annotations (e.g. for mesh injection or prometheus scraping)
  podAnnotations: {}
  # -- Additional Pod labels (e.g. for filtering Pod by custom labels)
  podLabels:
    app: traefik
  # -- Additional containers (e.g. for metric offloading sidecars)
  additionalContainers: []
  # https://docs.datadoghq.com/developers/dogstatsd/unix_socket/?tab=host
  # - name: socat-proxy
  #   image: alpine/socat:1.0.5
  #   args: ["-s", "-u", "udp-recv:8125", "unix-sendto:/socket/socket"]
  #   volumeMounts:
  #     - name: dsdsocket
  #       mountPath: /socket
  # -- Additional volumes available for use with initContainers and additionalContainers
  additionalVolumes: []
  # - name: dsdsocket
  #   hostPath:
  #     path: /var/run/statsd-exporter
  # -- Additional initContainers (e.g. for setting file permission as shown below)
  initContainers:
  # The "volume-permissions" init container is required if you run into permission issues.
  # Related issue: https://github.com/traefik/traefik-helm-chart/issues/396
   - name: volume-permissions
     image: busybox:latest
     command: ["sh","-c","touch /ssl-certs/acme-cloudflare.json; chmod -vR 600 /ssl-certs/*"]
     securityContext:
       runAsNonRoot: true
       runAsGroup: 65532
       runAsUser: 65532
     volumeMounts:
       - name: ssl-certs
         mountPath: /ssl-certs
  # -- Use process namespace sharing
  shareProcessNamespace: false
  # -- Custom pod DNS policy. Apply if `hostNetwork: true`
  # dnsPolicy: ClusterFirstWithHostNet
  dnsConfig: {}
  # nameservers:
  #   - 192.0.2.1 # this is an example
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0
  # -- Additional imagePullSecrets
  imagePullSecrets: []
  # - name: myRegistryKeySecretName
  # -- Pod lifecycle actions
  lifecycle: {}
  # preStop:
  #   exec:
  #     command: ["/bin/sh", "-c", "sleep 40"]
  # postStart:
  #   httpGet:
  #     path: /ping
  #     port: 9000
  #     host: localhost
  #     scheme: HTTP

# -- Pod disruption budget
podDisruptionBudget:
  enabled: false
  # maxUnavailable: 1
  # maxUnavailable: 33%
  # minAvailable: 0
  # minAvailable: 25%

# -- Create a default IngressClass for Traefik
ingressClass:
  enabled: true
  isDefaultClass: true
  # name: traefik-ingress

# Traefik experimental features
experimental:
  plugins:
    # -- Enable traefik experimental plugins
    enabled: false
  kubernetesGateway:
    # -- Enable traefik experimental GatewayClass CRD
    enabled: false
    gateway:
      # -- Enable traefik regular kubernetes gateway
      enabled: true
      # certificate:
      #   group: "core"
      #   kind: "Secret"
      #   name: "secret"
      # -- By default, Gateway would be created to the Namespace you are deploying Traefik to.
      # You may create that Gateway in another namespace, setting its name below:
      # namespace: default
      # Additional gateway annotations (e.g. for cert-manager.io/issuer)
      # annotations:
      #   cert-manager.io/issuer: letsencrypt

## Create an IngressRoute for the dashboard
ingressRoute:
  dashboard:
    enabled: true
    # -- Additional ingressRoute annotations (e.g. for kubernetes.io/ingress.class)
    annotations: {}
    # -- Additional ingressRoute labels (e.g. for filtering IngressRoute by custom labels)
    labels: {}
    # -- The router match rule used for the dashboard ingressRoute
    matchRule: PathPrefix(`/dashboard`) || PathPrefix(`/api`)
    # -- Specify the allowed entrypoints to use for the dashboard ingress route, (e.g. traefik, web, websecure).
    # By default, it's using traefik entrypoint, which is not exposed.
    # /!\ Do not expose your dashboard without any protection over the internet /!\
    entryPoints:
      - web
      - websecure
      - traefik
    # -- Additional ingressRoute middlewares (e.g. for authentication)
    middlewares: []
    # -- TLS options (e.g. secret containing certificate)
    tls: {}
  healthcheck:
    # -- Create an IngressRoute for the healthcheck probe
    enabled: false
    # -- Additional ingressRoute annotations (e.g. for kubernetes.io/ingress.class)
    annotations: {}
    # -- Additional ingressRoute labels (e.g. for filtering IngressRoute by custom labels)
    labels: {}
    # -- The router match rule used for the healthcheck ingressRoute
    matchRule: PathPrefix(`/ping`)
    # -- Specify the allowed entrypoints to use for the healthcheck ingress route, (e.g. traefik, web, websecure).
    # By default, it's using traefik entrypoint, which is not exposed.
    entryPoints: ["traefik"]
    # -- Additional ingressRoute middlewares (e.g. for authentication)
    middlewares: []
    # -- TLS options (e.g. secret containing certificate)
    tls: {}

updateStrategy:
  # -- Customize updateStrategy: RollingUpdate or OnDelete
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 1

readinessProbe:
  # -- The number of consecutive failures allowed before considering the probe as failed.
  failureThreshold: 2
  # -- The number of seconds to wait before starting the first probe.
  initialDelaySeconds: 5
  # -- The number of seconds to wait between consecutive probes.
  periodSeconds: 10
  # -- The minimum consecutive successes required to consider the probe successful.
  successThreshold: 3
  # -- The number of seconds to wait for a probe response before considering it as failed.
  timeoutSeconds: 2
livenessProbe:
  # -- The number of consecutive failures allowed before considering the probe as failed.
  failureThreshold: 3
  # -- The number of seconds to wait before starting the first probe.
  initialDelaySeconds: 5
  # -- The number of seconds to wait between consecutive probes.
  periodSeconds: 10
  # -- The minimum consecutive successes required to consider the probe successful.
  successThreshold: 1
  # -- The number of seconds to wait for a probe response before considering it as failed.
  timeoutSeconds: 2

providers:
  kubernetesCRD:
    # -- Load Kubernetes IngressRoute provider
    enabled: true
    # -- Allows IngressRoute to reference resources in namespace other than theirs
    allowCrossNamespace: false
    # -- Allows to reference ExternalName services in IngressRoute
    allowExternalNameServices: false
    # -- Allows to return 503 when there is no endpoints available
    allowEmptyServices: false
    # ingressClass: traefik-internal
    # labelSelector: environment=production,method=traefik
    # -- Array of namespaces to watch. If left empty, Traefik watches all namespaces.
    namespaces: []
    # - "default"

  kubernetesIngress:
    # -- Load Kubernetes Ingress provider
    enabled: true
    # -- Allows to reference ExternalName services in Ingress
    #####################################################################################################################
    #           This will be USEFUL for referencing external services such as admin portals for other systems           #
    #####################################################################################################################
    allowExternalNameServices: false
    # -- Allows to return 503 when there is no endpoints available
    allowEmptyServices: false
    # ingressClass: traefik-internal
    # labelSelector: environment=production,method=traefik
    # -- Array of namespaces to watch. If left empty, Traefik watches all namespaces.
    namespaces: []
    # - "default"
    # IP used for Kubernetes Ingress endpoints
    publishedService:
      enabled: false
      # Published Kubernetes Service to copy status from. Format: namespace/servicename
      # By default this Traefik service
      # pathOverride: ""
#volumes:
#  - name: ssl-certs
#    persistentVolumeClaim:
#      claimName: traefik-certs-claim

additionalVolumeMounts: []

logs:
  general:
    level: ERROR
  access:
    enabled: false
    filters: {}
    fields:
      general:
        defaultmode: keep
        names: {}
      headers:
        defaultmode: drop
        names: {}

metrics:
  prometheus:
    entryPoint: metrics

tracing: {}

globalArguments:
- "--global.checknewversion"
- "--global.sendanonymoususage"

additionalArguments:
# Enables the API Handler which is needed for the service api@internal to work (Ingress Routes such as 003-traefik-dash-ingress.yml)
  - --api=true
  - --api.insecure=true
####################### DNS Challenge With Cloudflare #######################
  - --entrypoints.websecure.http.tls.certresolver=cloudflare
  - --entrypoints.websecure.http.tls.domains[0].main=$(CF_MAIN_DOMAIN)
  - --entrypoints.websecure.http.tls.domains[0].sans=$(CF_SANS_DOMAIN)
  - --certificatesresolvers.cloudflare.acme.dnschallenge.provider=cloudflare
  - --certificatesresolvers.cloudflare.acme.email=$(CF_ACME_EMAIL)
  - --certificatesresolvers.cloudflare.acme.dnschallenge.resolvers=1.1.1.1
  - --certificatesresolvers.cloudflare.acme.storage=/ssl-certs/acme-cloudflare.json
#####################  HTTP Challenge With LetsEncrypt #####################
# Staging
#  - --certificatesresolvers.staging.acme.email=$(CF_ACME_EMAIL)
#  - --certificatesresolvers.staging.acme.caServer=https://acme-staging-v02.api.letsencrypt.org/directory
#  - --certificatesresolvers.staging.acme.httpChallenge.entryPoint=web
#  - --certificatesresolvers.staging.acme.storage=/ssl-certs/acme-staging.json
# Production
#  - --certificatesresolvers.production.acme.email=$(CF_ACME_EMAIL)
#  - --certificatesresolvers.production.acme.caServer=https://acme-v02.api.letsencrypt.org/directory
#  - --certificatesresolvers.production.acme.httpChallenge.entryPoint=web
#  - --certificatesresolvers.production.acme.storage=/ssl-certs/acme-production.json

# -- Environment variables to be passed to Traefik's binary
env:
- name: POD_NAME
  valueFrom:
    fieldRef:
      fieldPath: metadata.name
- name: POD_NAMESPACE
  valueFrom:
    fieldRef:
      fieldPath: metadata.namespace
# DNS Challenge Credentials And ACME Email
- name: CF_API_EMAIL
  valueFrom:
    secretKeyRef:
      key: email
      name: cf-creds
- name: CF_API_KEY
  valueFrom:
    secretKeyRef:
      key: apiKey
      name: cf-creds
- name: CF_ACME_EMAIL
  valueFrom:
    secretKeyRef:
      key: acmeEmail
      name: cf-creds
- name: CF_MAIN_DOMAIN
  valueFrom:
    secretKeyRef:
      key: cfDomainMain
      name: cf-creds
- name: CF_SANS_DOMAIN
  valueFrom:
    secretKeyRef:
      key: cfDomainSANS
      name: cf-creds
# -- Environment variables to be passed to Traefik's binary from configMaps or secrets
envFrom: []
# - configMapRef:
#     name: config-map-name
# - secretRef:
#     name: secret-name

ports:
  traefik:
    port: 9001
    expose: true
    exposedPort: 9001
    targetPort: 9001
    protocol: TCP
    nodePort: 30091
    # redirectTo: websecure
  web:
   # asDefault: true
    port: 8000
    expose: true
    exposedPort: 8080
    targetPort: web
    protocol: TCP
    nodePort: 30080
    redirectTo: websecure
    # Trust forwarded  headers information (X-Forwarded-*).
    # forwardedHeaders:
    #   trustedIPs: []
    #   insecure: false
    #
    # Enable the Proxy Protocol header parsing for the entry point
    proxyProtocol:
      trustedIPs:
        - 192.168.3.0/26
        - 172.18.0.0/16
      insecure: true # Just testing with 'true' might be better to leave 'false'
  websecure:
    # asDefault: true
    port: 8443
    expose: true
    exposedPort: 8443
    targetPort: 8443
    protocol: TCP
    nodePort: 30443
    appProtocol: https
    ## -- Enable HTTP/3 on the entrypoint
    ## Enabling it will also enable http3 experimental feature
    ## https://doc.traefik.io/traefik/routing/entrypoints/#http3
    ## There are known limitations when trying to listen on same ports for
    ## TCP & UDP (Http3). There is a workaround in this chart using dual Service.
    ## https://github.com/kubernetes/kubernetes/issues/47249#issuecomment-587960741
    http3:
      enabled: false
    # advertisedPort: 4443
    ## -- Trust forwarded  headers information (X-Forwarded-*).
    #forwardedHeaders:
    #  trustedIPs: []
    #  insecure: false
    ## -- Enable the Proxy Protocol header parsing for the entry point
    proxyProtocol:
      trustedIPs:
        - 192.168.3.0/26
        - 172.18.0.0/16
      insecure: true # Just testing with 'true' might be better to leave 'false'

####################################################################################################################
#                            BELOW IS TAKEN CARE OF IN THE 'additionalArguments' FIELD                             #
####################################################################################################################
    ## Set TLS at the entrypoint
    ## https://doc.traefik.io/traefik/routing/entrypoints/#tls
    tls:
      enabled: true
      options: ""
      certResolver: "cloudflare"
      domains: []
    # -- One can apply Middlewares on an entrypoint
    # https://doc.traefik.io/traefik/middlewares/overview/
    # https://doc.traefik.io/traefik/routing/entrypoints/#middlewares
    # -- /!\ It introduces here a link between your static configuration and your dynamic configuration /!\
    # It follows the provider naming convention: https://doc.traefik.io/traefik/providers/overview/#provider-namespace
    # middlewares:
    #   - namespace-name1@kubernetescrd
    #   - namespace-name2@kubernetescrd
    middlewares: []

  metrics:
    port: 9100
    expose: true
    exposedPort: 9100
    targetPort: 9100
    nodePort: 30901
    protocol: TCP

tlsOptions: {}

tlsStore:
  default:
    defaultCertificate:
      secretName: cf-tls

##############################################################################################
#                     This section is configured in traefik-service.yml                      #
##############################################################################################
service:
  enabled: true
  single: true
  type: LoadBalancer
  ports:
    - name: http
      protocol: TCP
      port: 8080
      targetPort: 8080
      nodePort: 30080
    - name: https
      protocol: TCP
      port: 8443
      targetPort: 8443
      nodePort: 30443
    - name: metrics
      protocol: TCP
      port: 9100
      targetPort: 9100
      nodePort: 30901
    - name: traefik
      protocol: TCP
      port: 9001
      targetPort: 9001
      nodePort: 30091
  selector:
    app: traefik
    namespace: traefik
  annotations: {}
  annotationsTCP: {}
  annotationsUDP: {}
  labels: {}
  spec: {}
  loadBalancerSourceRanges: []
  externalIPs:
    - 192.168.3.10

##############################################################################################################
#                               REPLICAS MUST BE SET TO 'NULL' FURTHER ABOVE                                 #
#   Disabling For Now Until A Certificate Issuer Is Deployed To Prevent Conflicts With HA And Let's Encrypt  #
##############################################################################################################
autoscaling:
#  # -- Create HorizontalPodAutoscaler object.
  enabled: false
#  minReplicas: 1
#  maxReplicas: 5
#  metrics:
#  - type: Resource
#    resource:
#       name: cpu
#       target:
#         type: Utilization
#         averageUtilization: 60
#  - type: Resource
#    resource:
#      name: memory
#      target:
#        type: Utilization
#        averageUtilization: 60
#  behavior:
#    scaleDown:
#      stabilizationWindowSeconds: 300
#      policies:
#      - type: Pods
#        value: 1
#        periodSeconds: 60

persistence:
  enabled: true
  name: ssl-certs
  existingClaim: "traefik-certs-claim"
  path: /ssl-certs
  annotations: {}
  # subPath: ""

######################################################################################################################
#                  'certResolvers' SECTION IS TAKEN CARE OF UNDER THE 'additionalArguments' FIELD                    #
######################################################################################################################
certResolvers: {}
hostNetwork: false

# -- Whether Role Based Access Control objects like roles and rolebindings should be created
rbac:
  enabled: true
  # If set to false, installs ClusterRole and ClusterRoleBinding so Traefik can be used across namespaces.
  # If set to true, installs Role and RoleBinding. Providers will only watch target namespace.
  namespaced: false
  # Enable user-facing roles
  # https://kubernetes.io/docs/reference/access-authn-authz/rbac/#user-facing-roles
  # aggregateTo: [ "admin" ]

# -- Enable to create a PodSecurityPolicy and assign it to the Service Account via RoleBinding or ClusterRoleBinding
podSecurityPolicy:
  enabled: false

# -- The service account the pods will use to interact with the Kubernetes API
serviceAccount:
  # If set, an existing service account is used
  # If not set, a service account is created automatically using the fullname template
  name: ""

# -- Additional serviceAccount annotations (e.g. for oidc authentication)
serviceAccountAnnotations: {}

# -- The resources parameter defines CPU and memory requirements and limits for Traefik's containers.
resources: {}
# This will be implemented when the cert-manager is in place with auto-scaling enabled
#  requests:
#    cpu: "500m"
#    memory: "300Mi"
#  limits:
#    cpu: "1000m"
#    memory: "600Mi"

affinity: {} # useful for hostNetwork enabled

nodeSelector: {}

tolerations: []

topologySpreadConstraints: []

priorityClassName: ""

securityContext:
  capabilities:
    drop: [ALL]
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false

podSecurityContext:
  fsGroupChangePolicy: "OnRootMismatch"
  runAsGroup: 65532
  runAsNonRoot: true
  runAsUser: 65532

extraObjects: []
